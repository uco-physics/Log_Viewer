<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Script Log Viewer</title>
  <!-- Bootstrap CDN: レスポンシブデザインとUIコンポーネント用 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- xterm.js CDN: ターミナルエミュレーション用 -->
  <link href="https://unpkg.com/xterm@5.3.0/css/xterm.css" rel="stylesheet">
  <style>
    /* 全体のスタイル: モダンでターミナル風のデザイン */
    body {
      background-color: #f8f9fa;
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    .container {
      max-width: 1200px;
      margin: auto;
      flex: 1;
    }

    /* 入力エリアのスタイル */
    .input-section {
      background-color: #ffffff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }

    .input-section textarea {
      width: 100%;
      min-height: 150px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      border: 1px solid #ced4da;
      border-radius: 4px;
      padding: 10px;
      resize: vertical;
    }

    /* 出力エリアのスタイル: ターミナル風 */
    #terminal-output {
      background-color: #1e1e1e;
      color: #ffffff;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      padding: 15px;
      border-radius: 8px;
      min-height: 300px;
      overflow-y: auto;
      position: relative;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    /* デバッグパネルのスタイル */
    #debug-panel {
      background-color: #ffffff;
      border: 1px solid #ced4da;
      border-radius: 8px;
      padding: 15px;
      margin-top: 20px;
      max-height: 200px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      display: none;
    }

    /* プログレスバーのスタイル */
    #progress-bar {
      transition: width 0.3s ease-in-out;
    }

    /* ボタンのホバー効果 */
    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    /* レスポンシブデザイン: 小さい画面での調整 */
    @media (max-width: 768px) {
      .input-section textarea {
        min-height: 100px;
      }
      #terminal-output {
        font-size: 12px;
        min-height: 200px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="text-center mb-4">Script Log Viewer</h1>

    <!-- 入力セクション -->
    <div class="input-section">
      <h3>ログ入力</h3>
      <!-- 入力方法のトグル -->
      <div class="mb-3">
        <label class="form-label">入力方法</label>
        <div>
          <input type="radio" name="input-method" id="input-file" value="file" checked>
          <label for="input-file">ファイルアップロード</label>
          <input type="radio" name="input-method" id="input-text" value="text">
          <label for="input-text">テキスト入力</label>
        </div>
      </div>

      <!-- タイムスタンプのトグル -->
      <div class="mb-3">
        <input type="checkbox" id="use-timestamp">
        <label for="use-timestamp">タイムスタンプを使用</label>
      </div>

      <!-- ファイル入力 -->
      <div id="file-inputs" class="mb-3">
        <label for="log-file" class="form-label">ログファイル</label>
        <input type="file" id="log-file" class="form-control" accept=".log,.txt">
        <label for="timestamp-file" class="form-label mt-2" id="timestamp-file-label" style="display: none;">タイムスタンプファイル</label>
        <input type="file" id="timestamp-file" class="form-control" accept=".log,.txt" style="display: none;">
      </div>

      <!-- テキスト入力 -->
      <div id="text-inputs" style="display: none;">
        <label for="log-text" class="form-label">ログテキスト</label>
        <textarea id="log-text" class="form-control" placeholder="ここにログをペースト"></textarea>
        <label for="timestamp-text" class="form-label mt-2" id="timestamp-text-label" style="display: none;">タイムスタンプテキスト</label>
        <textarea id="timestamp-text" class="form-control" placeholder="ここにタイムスタンプをペースト" style="display: none;"></textarea>
      </div>

      <!-- レンダリングボタン -->
      <button id="render-btn" class="btn btn-primary mt-3">レンダリング開始</button>
    </div>

    <!-- プログレスバー -->
    <div class="progress mb-3" style="height: 20px;">
      <div id="progress-bar" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
    </div>

    <!-- 出力セクション -->
    <div class="output-section">
      <h3>ターミナル出力</h3>
      <div class="d-flex justify-content-end mb-2">
        <button id="copy-plain-btn" class="btn btn-secondary me-2" disabled>プレーンテキストをコピー</button>
        <button id="copy-raw-btn" class="btn btn-secondary me-2" disabled>生ログをコピー</button>
        <button id="download-plain-btn" class="btn btn-secondary me-2" disabled>プレーンテキストをダウンロード</button>
        <button id="download-raw-btn" class="btn btn-secondary" disabled>生ログをダウンロード</button>
      </div>
      <div id="terminal-output"></div>
    </div>

    <!-- デバッグパネル -->
    <div class="mt-3">
      <button id="toggle-debug-btn" class="btn btn-outline-secondary">デバッグパネルを表示/非表示</button>
      <div id="debug-panel"></div>
    </div>
  </div>

  <!-- 外部ライブラリ -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://unpkg.com/xterm@5.3.0/lib/xterm.js"></script>
  <script src="https://unpkg.com/ansi-to-html@0.7.2/lib/ansi_to_html.js"></script>

  <script>
    // 全体のアーキテクチャ概要
    // このアプリケーションは、Linuxの`script`コマンドで生成されたログをブラウザ上でターミナル風に表示します。
    // 主要コンポーネント:
    // 1. InputHandler: ファイルまたはテキスト入力の処理
    // 2. LogParser: ANSIエスケープシーケンスとタイムスタンプの解析
    // 3. Renderer: ターミナル風のレンダリング（xterm.jsとansi-to-htmlを使用）
    // 4. OutputManager: コピー/ダウンロード機能
    // 5. DebugLogger: デバッグ情報の管理
    // 処理フロー:
    // 1. ユーザーがログ（とオプションでタイムスタンプ）を入力
    // 2. チャンク単位でログを解析し、HTMLに変換
    // 3. ターミナル風に出力
    // 4. コピー/ダウンロード機能を提供
    // 5. デバッグ情報を表示

    // グローバル変数
    let logContent = ''; // ログの内容
    let timestampContent = ''; // タイムスタンプの内容
    let parsedOutput = ''; // 解析済みのプレーンテキスト
    let rawOutput = ''; // 生ログ
    const ansiConverter = new AnsiToHTML(); // ansi-to-htmlインスタンス
    let isProcessing = false; // 処理中フラグ

    // デバッグログを追加する関数
    // 引数: message (文字列) - デバッグメッセージ
    function addDebugLog(message) {
      const debugPanel = document.getElementById('debug-panel');
      const timestamp = new Date().toLocaleTimeString('ja-JP');
      debugPanel.innerHTML += `[${timestamp}] ${message}<br>`;
      debugPanel.scrollTop = debugPanel.scrollHeight;
      console.log(`[DEBUG] ${message}`);
    }

    // プログレスバーを更新する関数
    // 引数: percentage (数値) - 進捗率（0-100）
    function updateProgress(percentage) {
      const progressBar = document.getElementById('progress-bar');
      progressBar.style.width = `${percentage}%`;
      progressBar.setAttribute('aria-valuenow', percentage);
    }

    // 入力方法のトグルを処理する関数
    function handleInputMethodToggle() {
      const fileInputs = document.getElementById('file-inputs');
      const textInputs = document.getElementById('text-inputs');
      const inputMethod = document.querySelector('input[name="input-method"]:checked').value;
      fileInputs.style.display = inputMethod === 'file' ? 'block' : 'none';
      textInputs.style.display = inputMethod === 'text' ? 'block' : 'none';
      addDebugLog(`入力方法を${inputMethod}に変更`);
    }

    // タイムスタンプトグルの処理
    function handleTimestampToggle() {
      const useTimestamp = document.getElementById('use-timestamp').checked;
      document.getElementById('timestamp-file-label').style.display = useTimestamp ? 'block' : 'none';
      document.getElementById('timestamp-file').style.display = useTimestamp ? 'block' : 'none';
      document.getElementById('timestamp-text-label').style.display = useTimestamp ? 'block' : 'none';
      document.getElementById('timestamp-text').style.display = useTimestamp ? 'block' : 'none';
      addDebugLog(`タイムスタンプ使用: ${useTimestamp}`);
    }

    // ファイル読み込み関数
    // 引数: file (Fileオブジェクト) - 読み込むファイル
    // 戻り値: Promise - ファイルの内容（文字列）
    async function readFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(new Error('ファイル読み込みに失敗しました'));
        reader.readAsText(file);
      });
    }

    // ログファイルの処理
    async function handleLogFile() {
      const logFileInput = document.getElementById('log-file');
      const logTextArea = document.getElementById('log-text');
      if (logFileInput.files.length > 0) {
        try {
          logContent = await readFile(logFileInput.files[0]);
          logTextArea.value = logContent;
          addDebugLog('ログファイル読み込み成功');
        } catch (error) {
          addDebugLog(`ログファイル読み込みエラー: ${error.message}`);
          alert('ログファイルの読み込みに失敗しました。');
        }
      }
    }

    // タイムスタンプファイルの処理
    async function handleTimestampFile() {
      const timestampFileInput = document.getElementById('timestamp-file');
      const timestampTextArea = document.getElementById('timestamp-text');
      if (timestampFileInput.files.length > 0) {
        try {
          timestampContent = await readFile(timestampFileInput.files[0]);
          timestampTextArea.value = timestampContent;
          addDebugLog('タイムスタンプファイル読み込み成功');
        } catch (error) {
          addDebugLog(`タイムスタンプファイル読み込みエラー: ${error.message}`);
          alert('タイムスタンプファイルの読み込みに失敗しました。');
        }
      }
    }

    // ログをチャンク単位で処理する関数
    // 引数: log (文字列) - 処理するログ
    // 戻り値: { plain: プレーンテキスト, raw: 生ログ }
    async function processLogChunks(log) {
      const CHUNK_SIZE = 1024 * 1024; // 1MBのチャンク
      let plainText = '';
      let rawText = log;
      const totalChunks = Math.ceil(log.length / CHUNK_SIZE);

      for (let i = 0; i < log.length; i += CHUNK_SIZE) {
        const chunk = log.slice(i, i + CHUNK_SIZE);
        try {
          // ANSIエスケープシーケンスをHTMLに変換
          const htmlChunk = ansiConverter.toHtml(chunk);
          plainText += stripAnsi(chunk); // プレーンテキスト用に制御文字を除去
          updateProgress(((i + CHUNK_SIZE) / log.length) * 100);
          addDebugLog(`チャンク${i / CHUNK_SIZE + 1}/${totalChunks}を処理`);
          // 非同期処理の遅延を防ぐためにawait
          await new Promise(resolve => setTimeout(resolve, 0));
        } catch (error) {
          addDebugLog(`チャンク処理エラー: ${error.message}`);
        }
      }

      return { plain: plainText, raw: rawText };
    }

    // ANSIエスケープシーケンスを除去する関数
    // 引数: text (文字列) - 処理するテキスト
    // 戻り値: 制御文字を除去したテキスト
    function stripAnsi(text) {
      return text.replace(/\x1B\[[0-?]*[ -/]*[@-~]/g, '');
    }

    // ターミナルにレンダリングする関数
    // 引数: log (文字列) - レンダリングするログ
    async function renderTerminal(log) {
      const terminalOutput = document.getElementById('terminal-output');
      terminalOutput.innerHTML = ''; // 既存の内容をクリア

      try {
        const htmlOutput = ansiConverter.toHtml(log);
        terminalOutput.innerHTML = htmlOutput;
        addDebugLog('ターミナルレンダリング完了');
      } catch (error) {
        addDebugLog(`レンダリングエラー: ${error.message}`);
        terminalOutput.innerHTML = 'レンダリング中にエラーが発生しました。';
      }
    }

    // コピー機能
    function copyToClipboard(text, type) {
      navigator.clipboard.writeText(text).then(() => {
        addDebugLog(`${type}をクリップボードにコピー`);
        alert(`${type}をクリップボードにコピーしました。`);
      }).catch(err => {
        addDebugLog(`コピーエラー: ${err.message}`);
        alert('コピーに失敗しました。');
      });
    }

    // ダウンロード機能
    function downloadFile(content, filename) {
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
      addDebugLog(`${filename}をダウンロード`);
    }

    // レンダリングボタンのハンドラ
    async function handleRender() {
      if (isProcessing) return;
      isProcessing = true;
      updateProgress(0);
      const renderBtn = document.getElementById('render-btn');
      renderBtn.disabled = true;

      try {
        const inputMethod = document.querySelector('input[name="input-method"]:checked').value;
        const useTimestamp = document.getElementById('use-timestamp').checked;

        // 入力の取得
        if (inputMethod === 'file') {
          await handleLogFile();
          if (useTimestamp) await handleTimestampFile();
        } else {
          logContent = document.getElementById('log-text').value;
          if (useTimestamp) timestampContent = document.getElementById('timestamp-text').value;
        }

        if (!logContent) {
          throw new Error('ログ内容がありません。');
        }

        addDebugLog('ログ処理開始');
        const { plain, raw } = await processLogChunks(logContent);
        parsedOutput = plain;
        rawOutput = raw;

        // ターミナルにレンダリング
        await renderTerminal(logContent);

        // ボタンを有効化
        document.getElementById('copy-plain-btn').disabled = false;
        document.getElementById('copy-raw-btn').disabled = false;
        document.getElementById('download-plain-btn').disabled = false;
        document.getElementById('download-raw-btn').disabled = false;

        addDebugLog('処理完了');
      } catch (error) {
        addDebugLog(`処理エラー: ${error.message}`);
        alert(`エラーが発生しました: ${error.message}`);
      } finally {
        isProcessing = false;
        renderBtn.disabled = false;
        updateProgress(100);
      }
    }

    // 初期化関数
    function init() {
      // イベントリスナーの設定
      document.getElementById('input-file').addEventListener('change', handleInputMethodToggle);
      document.getElementById('input-text').addEventListener('change', handleInputMethodToggle);
      document.getElementById('use-timestamp').addEventListener('change', handleTimestampToggle);
      document.getElementById('render-btn').addEventListener('click', handleRender);
      document.getElementById('toggle-debug-btn').addEventListener('click', () => {
        const debugPanel = document.getElementById('debug-panel');
        debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
        addDebugLog(`デバッグパネル${debugPanel.style.display === 'none' ? '非表示' : '表示'}`);
      });

      // コピー/ダウンロードボタンのイベント
      document.getElementById('copy-plain-btn').addEventListener('click', () => copyToClipboard(parsedOutput, 'プレーンテキスト'));
      document.getElementById('copy-raw-btn').addEventListener('click', () => copyToClipboard(rawOutput, '生ログ'));
      document.getElementById('download-plain-btn').addEventListener('click', () => downloadFile(parsedOutput, 'log_plain.txt'));
      document.getElementById('download-raw-btn').addEventListener('click', () => downloadFile(rawOutput, 'log_raw.txt'));

      // データ消失防止
      window.onbeforeunload = () => logContent || timestampContent ? '入力データが失われます。続行しますか？' : null;

      // ドラッグ＆ドロップの設定
      const fileInputs = document.querySelectorAll('input[type="file"]');
      fileInputs.forEach(input => {
        input.addEventListener('dragover', e => e.preventDefault());
        input.addEventListener('drop', async e => {
          e.preventDefault();
          input.files = e.dataTransfer.files;
          if (input.id === 'log-file') await handleLogFile();
          if (input.id === 'timestamp-file') await handleTimestampFile();
        });
      });

      addDebugLog('アプリケーション初期化完了');
    }

    // アプリケーションの起動
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
